# Purpose:
#   1) Generate a set of patterns of given length (pattern = [type_0, +gap_0, type_1, +gap_1, ..., type_{L-1}])
#   2) Based on the pattern set, generate an event stream of "integer timestamp + event type"
#      - Configurable random event ratio
#      - Configurable "pattern gap jitter" (on/off, amount, distribution)
#      - Configurable "random event interval generation method" (base interval, jitter, distribution)
#      - Optional: time-varying density (rate) and type distribution drift (for
#        assigning types to random events)
# Design goals: efficient (numpy array storage), streamable, easy to reproduce experiments (seed)
# Note: This file's code was generated by an LLM. Although some parts have been modified, it may still contain errors or imperfections. Further review and corrections are necessary.

from __future__ import annotations
import numpy as np
from pathlib import Path
import pickle
import hashlib
from tqdm import tqdm
from typing import Literal, Tuple, List, Optional
import time


JitterDist = Literal["none", "uniform", "gaussian", "laplace"]
IntervalDist = Literal["fixed", "poisson", "geometric", "uniform"]
DensityMode = Literal["none", "sin"]


def _rng(seed: int) -> np.random.Generator:
    return np.random.default_rng(int(seed))


def _apply_jitter_int(
    base: int,
    dist: JitterDist,
    amount: int,
    rng: np.random.Generator,
    min_val: int = 1,
) -> int:
    """
    
    Apply jitter to "pattern gaps" or "random intervals", ensuring the output is an integer >= min_val.
    The meaning of amount:
      - uniform: discrete uniform jitter in [-amount, +amount]
      - gaussian: normal random with mean 0 and std dev = amount, rounded
      - laplace: Laplace random with mean 0 and b = amount, rounded
      - none: no jitter
    """
    if dist == "none" or amount <= 0:
        return max(min_val, int(base))

    if dist == "uniform":
        delta = rng.integers(-amount, amount + 1)
    elif dist == "gaussian":
        delta = int(np.round(rng.normal(0, amount)))
    elif dist == "laplace":
        # numpy's laplace(scale=b), we use amount as scale
        delta = int(np.round(rng.laplace(0.0, amount)))
    else:
        raise ValueError(f"Unknown jitter dist: {dist}")

    return max(min_val, int(base + delta))


def _sample_interval_int(
    base: int,
    dist: IntervalDist,
    rng: np.random.Generator,
    low: Optional[int] = None,
    high: Optional[int] = None,
) -> int:
    """
    Sample the base interval for "random events" (before applying jitter/density scaling).
      - fixed:  constant base
      - poisson: sample from Poisson(λ=base) (ensured >=1)
      - geometric: geometric distribution (p = 1/base), expected about base (ensured >=1)
      - uniform: discrete uniform in [low, high] (requires low, high)
    """
    if dist == "fixed":
        return max(1, int(base))
    elif dist == "poisson":
        # Avoid zero
        return max(1, int(rng.poisson(max(1e-9, float(base)))))
    elif dist == "geometric":
        p = 1.0 / max(1.0, float(base))
        # numpy geometric distribution starts from 1
        return int(rng.geometric(p))
    elif dist == "uniform":
        if low is None or high is None or low < 1 or high < low:
            raise ValueError("uniform interval requires valid [low, high] with low>=1")
        return int(rng.integers(low, high + 1))
    else:
        raise ValueError(f"Unknown interval dist: {dist}")


def _density_scale(
    t: int, mode: DensityMode, base_rate: float, period: int, amp: float
) -> float:
    """
    
    Density control: returns a "rate scaling" factor r(t).
    You can think of it as "current event rate / base rate", which we use to
    shorten or lengthen intervals (interval' = max(1, round(interval / r(t)))).
    - mode='none': r(t)=1
    - mode='sin': r(t)=base_rate * (1 + amp * sin(2π t / period))
      Note: amp ∈ [0, 1) is reasonable; base_rate is usually 1.0
    """
    if mode == "none":
        return 1.0
    elif mode == "sin":
        # Ensure positive value
        r = base_rate * (1.0 + amp * np.sin(2.0 * np.pi * (t / max(1, period))))
        return max(1e-6, float(r))
    else:
        raise ValueError(f"Unknown density mode: {mode}")


class PatternSet:
    """
    Pattern set: contains n patterns each of length L.
    Each pattern consists of:
      - types: an integer array of length L (event types)
      - gaps:  an integer array of length L-1 (intervals between adjacent events in the pattern, in integer time units)
    """

    def __init__(self, types: np.ndarray, gaps: np.ndarray):
        self.types = types  # shape: [n_patterns, L]
        self.gaps = gaps  # shape: [n_patterns, L-1]

    @property
    def n_patterns(self) -> int:
        return self.types.shape[0]

    @property
    def length(self) -> int:
        return self.types.shape[1]

    def __len__(self) -> int:
        return self.n_patterns


def generate_patterns(
    n_patterns: int,
    pattern_length: int,
    n_types: int,
    gap_dist: IntervalDist = "uniform",
    gap_base: int = 5,
    gap_low: Optional[int] = 2,
    gap_high: Optional[int] = 9,
    seed: int = 137,
) -> PatternSet:
    """
    Generate a set of patterns.
      - Event types are uniformly sampled from [0, n_types-1] (duplicates allowed)
      - Pattern gaps are sampled from the specified distribution (all integers >=1)

    Parameters:
    ----
    n_patterns: Number of patterns to generate
    pattern_length: Pattern length L (number of events)
    n_types: Total number of event types
    gap_dist: Distribution type for pattern gaps ('fixed'/'poisson'/'geometric'/'uniform')
    gap_base: Base parameter for fixed/poisson/geometric distributions
    gap_low/gap_high: Range for uniform distribution
    """
    if pattern_length < 2:
        raise ValueError("pattern_length must be >= 2")
    rng = _rng(seed)

    # Event types matrix [n_patterns, L]
    types = rng.integers(0, n_types, size=(n_patterns, pattern_length), dtype=np.int32)

    # Gaps matrix [n_patterns, L-1]
    gaps = np.empty((n_patterns, pattern_length - 1), dtype=np.int32)
    for i in range(n_patterns):
        for j in range(pattern_length - 1):
            gaps[i, j] = _sample_interval_int(
                base=gap_base,
                dist=gap_dist,
                rng=rng,
                low=gap_low,
                high=gap_high,
            )

    return PatternSet(types=types, gaps=gaps)


class EventStream:
    """
    
    Generate an event stream of "integer timestamps + event types" from a set of patterns.
    Supports parameters:
      - random event ratio random_ratio
      - pattern gap jitter (on/off, amount, distribution)
      - random event interval generation method (distribution + jitter)ƒ
      - density mode (controls rate variation over time)
    """

    def __init__(
        self,
        patterns: PatternSet,
        n_types: int,
        total_events: int,
        random_ratio: float,
        seed: int = 123,
        # Pattern gap jitter
        pattern_jitter: JitterDist = "uniform",
        pattern_jitter_amount: int = 0,
        # Random event interval generation method
        rand_interval_dist: IntervalDist = "poisson",
        rand_interval_base: int = 5,
        rand_interval_low: Optional[int] = 2,
        rand_interval_high: Optional[int] = 9,
        rand_jitter: JitterDist = "uniform",
        rand_jitter_amount: int = 1,
        # Density control (applies to all intervals)
        density_mode: DensityMode = "none",
        density_period: int = 10_000,
        density_amp: float = 0.8,
        density_base_rate: float = 1.0,
        # Cache (optional)
        cache_dir: Optional[str] = None,
        regenerate: bool = False,
    ):
        assert 0.0 <= random_ratio <= 1.0
        self.patterns = patterns
        self.n_types = n_types
        self.total_events = int(total_events)
        self.random_ratio = float(random_ratio)
        self.rng = _rng(seed)

        self.pattern_jitter = pattern_jitter
        self.pattern_jitter_amount = int(pattern_jitter_amount)

        self.rand_interval_dist = rand_interval_dist
        self.rand_interval_base = int(rand_interval_base)
        self.rand_interval_low = (
            None if rand_interval_low is None else int(rand_interval_low)
        )
        self.rand_interval_high = (
            None if rand_interval_high is None else int(rand_interval_high)
        )
        self.rand_jitter = rand_jitter
        self.rand_jitter_amount = int(rand_jitter_amount)

        self.density_mode = density_mode
        self.density_period = int(density_period)
        self.density_amp = float(density_amp)
        self.density_base_rate = float(density_base_rate)

        # Cache key
        self.cache_path = None
        if cache_dir is not None:
            cache_dir = Path(cache_dir)
            cache_dir.mkdir(parents=True, exist_ok=True)
            key = (
                f"{patterns.n_patterns}-{patterns.length}-{n_types}-"
                f"{total_events}-{random_ratio}-{seed}-"
                f"{pattern_jitter}-{pattern_jitter_amount}-"
                f"{rand_interval_dist}-{rand_interval_base}-"
                f"{rand_interval_low}-{rand_interval_high}-"
                f"{rand_jitter}-{rand_jitter_amount}-"
                f"{density_mode}-{density_period}-{density_amp}-{density_base_rate}"
            )
            h = hashlib.md5(key.encode()).hexdigest()[:10]
            self.cache_path = cache_dir / f"stream_{h}.pkl"

        # 生成或加载
        if self.cache_path and self.cache_path.exists() and not regenerate:
            with open(self.cache_path, "rb") as f:
                data = pickle.load(f)
            self.timestamps = data["timestamps"]
            self.types = data["types"]
            self.is_pattern = data["is_pattern"]
        else:
            self.timestamps, self.types, self.is_pattern = self._generate_stream()
            if self.cache_path:
                with open(self.cache_path, "wb") as f:
                    pickle.dump(
                        {
                            "timestamps": self.timestamps,
                            "types": self.types,
                            "is_pattern": self.is_pattern,
                        },
                        f,
                    )

    # ------------------------ 核心生成 ------------------------

    def _generate_stream(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        
        Improved event stream generation logic:
        - Pattern instances and random events are interleaved according to the ratio, rather than alternating in blocks.
        - Events within a pattern remain intact (written continuously without interruption by random events).
        - Random events are inserted between patterns to satisfy the random_ratio.
        """
        rng = self.rng
        L = self.patterns.length
        N = self.total_events

        # Target ratios and target event counts
        target_random = int(round(N * self.random_ratio))
        target_pattern = N - target_random

        timestamps = np.empty(N, dtype=np.int64)
        types = np.empty(N, dtype=np.int32)
        is_pattern = np.empty(N, dtype=bool)

        t = 0
        i = 0
        n_random = 0
        n_pattern = 0

        # Helper function: insert a random event
        def insert_random_event(t_current: int) -> int:
            nonlocal i, n_random
            # Sample random interval
            base_int = _sample_interval_int(
                base=self.rand_interval_base,
                dist=self.rand_interval_dist,
                rng=rng,
                low=self.rand_interval_low,
                high=self.rand_interval_high,
            )
            base_int = _apply_jitter_int(
                base=base_int,
                dist=self.rand_jitter,
                amount=self.rand_jitter_amount,
                rng=rng,
                min_val=1,
            )
            r = _density_scale(
                t=t_current,
                mode=self.density_mode,
                base_rate=self.density_base_rate,
                period=self.density_period,
                amp=self.density_amp,
            )
            gap = max(1, int(round(base_int / r)))
            t_next = t_current + gap

            et = int(rng.choice(self.n_types))

            timestamps[i] = t_next
            types[i] = et
            is_pattern[i] = False
            # i += 1
            n_random += 1
            return t_next

        # Helper function: insert a complete pattern instance
        def insert_pattern_instance(t_current: int) -> int:
            nonlocal i, n_pattern
            idx = i
            pid = int(rng.integers(0, self.patterns.n_patterns))
            p_types = self.patterns.types[pid]
            p_gaps = self.patterns.gaps[pid]
            for j in range(L):
                timestamps[idx] = t_current
                types[idx] = p_types[j]
                is_pattern[idx] = True
                idx += 1
                n_pattern += 1
                if idx >= N:
                    return t_current
                if j < L - 1:
                    gap = int(p_gaps[j])
                    gap = _apply_jitter_int(
                        base=gap,
                        dist=self.pattern_jitter,
                        amount=self.pattern_jitter_amount,
                        rng=rng,
                        min_val=1,
                    )
                    r = _density_scale(
                        t=t_current,
                        mode=self.density_mode,
                        base_rate=self.density_base_rate,
                        period=self.density_period,
                        amp=self.density_amp,
                    )
                    eff = max(1, int(round(gap / r)))
                    t_current += eff
            # Add a small interval after the pattern ends
            t_current += 1
            return t_current

        # Main loop: generate events one by one
        with tqdm(total=N, desc="Generating events...") as pbar:
            i = 0
            while i < N:
                # Current random event ratio
                ratio_now = n_random / max(1, (n_random + n_pattern))
                # Decision: if current ratio < target ratio, insert random event; otherwise insert pattern
                if (
                    ratio_now < self.random_ratio or n_pattern + L > target_pattern
                ) and n_random < target_random:
                    t = insert_random_event(t)
                    i += 1
                else:
                    t = insert_pattern_instance(t)
                    i += L
                pbar.update(i - pbar.n)

        # 裁剪（防止越界）
        timestamps = timestamps[:N]
        types = types[:N]
        is_pattern = is_pattern[:N]

        return timestamps, types, is_pattern

    # ------------------------ Export and Iteration ------------------------

    def to_numpy(self) -> np.ndarray:
        """Return a ndarray with shape=[N,3] (timestamp,event_type,is_pattern)"""
        return np.stack([self.timestamps, self.types, self.is_pattern], axis=1)

    def to_csv(self, path: str):
        """Save as CSV: timestamp,event_type,is_pattern"""
        arr = self.to_numpy()
        np.savetxt(
            path,
            arr,
            delimiter=",",
            header="timestamp,event_type,is_pattern",
            comments="",
            fmt="%d,%d,%d",
        )

    def stream(self):
        """Stream iterator: yield (timestamp:int, event_type:int, is_pattern:bool)"""
        for t, e, p in zip(self.timestamps, self.types, self.is_pattern):
            yield int(t), int(e), bool(p)
